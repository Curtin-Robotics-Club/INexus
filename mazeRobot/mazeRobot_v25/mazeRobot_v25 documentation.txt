Copied directly from mazeRobot_v2, it was getting a bit annoying to scroll through
There is an explaination at the bottom of the page, might be out of date
*****************************************
07/11/2011
to do:
	  solve thinking 2 bridges are a cross (need extra sensors I think)
	  test returning if run out of time
	  change isUnknown() in Maze
	  full test of mapping phase
	  Fix left orthogonal turn (needs slight adjustment)
	  Fix diagonal turns (some of them are a fair bit off at times)
	  Tweak moveTillPoint() in Robot so that the robot stops at the right point for bridges
	  add wait for and deliver blocks phase
	  

Changed a lot of variables to local, made mapping and testing into 2 seperate functions which are called inside loop()
Added functions:
	//returns if the sensors might be seeing a bridge on the right
	bool isPotentialRightBridge(unsigned int* sensors);
	//returns if the sensors might be seeing a bridge on the left
	bool isPotentialLeftBridge(unsigned int* sensors);
	//returns true if sensors are [O|O| | | | |O|O]
	bool onCross(unsigned int* sensors);
	//Check if any of the four centre sensors are black (intensity of black adjusted for noise)
	bool isUnpassable();
	//Checks if we've gone overtime, if so then navigates to startPoint and returns true
	bool overTime(unsigned long startTimeInMillis, int loopCount, const int NUMPOINTS);
	//go backwards while adjusting for error
	void reverse();
	//checks if the ticks after startTicks are within a range divided by scale, scale = 1 for a cross, scale = 2 for bridges
	bool withinExpectedTicks(int startTicks, int scale);
	//maps maze and signals completion, will not go overtime
	void createMapOfMaze();
	//loops through testing points to ensure mapping was done correctly and test navigation
	void loopThroughTestingPointsIndefinitely();
mainly to increase readability.
Added a check for ticks to help with false positives and missed points of interest,
to disable make withinExpectedTicks() always return true and remove if statement inside while loop that calls reverse()

In Robot getTicks() was added, moveTillPoint() is more complicated and can handle bridges, queryPoint() was implemented but is buggy, 
errorAdustment is now turned ON for diagonal movement (we're following a line) and large corrections were turned off

in Maze a break if at goal point was commented out, seems to work fine but if there is an issue with path finding try uncommenting it.
Also commenting was updated
*****************************************	
02/11/2011
Made isCross(), isPotentialLeftBridge(), isPotentialRightBridge() (They just make the if statements easier to read)
Updated commenting
Cleaned up the testing code so that it looks respectable
Changed moveTo() so that it traverses bridges, tested with bridges, works
to do:
	  solve thinking 2 bridges are a cross
	  test returning if run out of time
	  change isUnknown() in grid
	  full test of mapping phase
*****************************************
22/9/2011
Added a check to the bridge finding algorithm, if a bridge has already been found the bridge direction then it skips the whole thing
Added a check to the bridge finding algorithm, if the lastError says we're on a large angle then don't do it (we could be hitting a cross on an angle)
Changed the bridge algorithm from [ |O| |O?|O?| |X|X] to [O| | | |O| |X|X] (and vice versa for the other bridge), might change to:[O| | | |O|X|X|X]
Changed errorSensorAdjustment(), errorTickAdjustment(), errorAdjustment() and turnTo() in Robot
Error works better now and turnTo() now ends with the centre sensors on the line, so mapping works a lot better
added lastError for bridges
Changed DELAY_TO_CHECK_READING and DELAY_TO_CHECK_ANGLE to try and eliminate false positives for bridge finding, still a few though, none on crosses though
Tested finding unpassable nodes, works
Removed MOTOR_LEFT_ERROR_CORRECT and MOTOR_RIGHT_ERROR_CORRECT, they weren't being used
to do:
      fix up bridge detection (almost done)
	  solve thinking 2 bridges are a cross
	  test following a path generated by the path planner (tested without bridges, works)
	  test returning if run out of time
	  change isUnknown() in grid
	  full test of mapping phase
******************************************
18/9/2011
**fixed**: needed to disable new additions to setTerrain(Direction) for mapping to work correctly (had x += 1 but new code changed the value of x)
Changed from Grid to Maze, some old comments might now read: "need to change from maze to maze..."  Compiled.
Changed to latest version of Robot, changed to updated version of Grid, compiling with no problems.  Some parts of Grid though are untested.
Added signal that mapping is finished by waving arms.
changed initialisation of grid to account for non-sqare grids
changed initialisation of grid to kill links to points out of range
commented functions in grid
removed motorForwardError now that we're using robot.errorAdjust()
to do:
      fix up bridge detection
	  solve thinking 2 bridges are a cross
	  test finding unpassable nodes
	  test following a path generated by the path planner
	  test returning if run out of time
	  change isUnknown() in grid
	  rename grid to maze
	  full test of mapping phase
******************************************
17/9/2011
The grid has been tested and it stores things correctly.  Grid representation DONE
Path planning has been tested and it works but assumes no unknown nodes.  Path planning ESSENTIALLY DONE
to do:
      fix up bridge detection
	  solve thinking 2 bridges are a cross
	  test finding unpassable nodes
	  test following a path generated by the path planner
	  test returning if run out of time
	  change isUnknown() in grid
	  rename grid to maze
	  make the robot signal it's done
	  comment some functions in grid
	  change initialisation in grid to kill links out of the grids range
	  change initialisation in grid to account for non-square grids
	  full test of mapping
******************************************
16/9/2011
Testing, changed little things: now it successfully traverses from point to point for the mapping phase
Added a function to print off the grid that the robot has seen, not yet tested
Shuffled function defenitions so they are below the loop()
Killed a few comments, shuffled a few, formatted some stuff
***************************************** 
15/9/2011
Fixed major logic problem with main while loop in mapping part
FATAL ERROR not dealt with.
Checked the logic of turnToPoint and we can turn to nextNode without problems.  Removed tempNode.
currentNode has been retired, turned into bridgeNode with corresponding getBridgeNode()
Noticed another problem (similar to FATAL ERROR): If there are two bridges at all, the robot will only record one of them but:
bridgeFound turned into leftBridgeFound and rightBridgeFound.  Setting bridges is now delayed until nextNode has been reached.  Problem above is solved.
Finding a cross now stops the robot until all grid calibrations are done
Reorganised code to group initialisations together more nicely
In mapping phase the for loop has been changed to iterate through a list of points instead of coordinates to make it less confusing for people
Switched getLeftConnection() and getRightConnection() as they are now used for a slightly different purpose
Updated commenting, documentation should be in line with what the program is doing
Coded testGrid.pde and testCrossDetection.pde to do testing.  Hopefully the while loop fix gets rid of the need for testCrossDetection and hopefully the grid is ok too.
Plan to go do more testing tomorrow.
******************************************
14/9/2011
Did some testing but was remiss with my note taking. (Also very confused...)
Discovered an error in turnToPoint (it used a different coordinate system).  Fixed that and made a "tempNode" to ensure the node it was turning to was right next to our current node
Inserted callibration routine in setup and also a wait routine so the robot waits until we tell it to start.
******************************************
13/9/2011
Changes made so that information is not stored in centres, functions removed etc.
BIG changes in grid, the main difference this function sees is that setting a node to PASSABLE cuts off all the bridge connections
BEWARE, some documentation will not be correct



FATAL ERROR:



Will regard bridges like this:
  _ _ _ _ 
 | \ | / |
 |_ _|_ _|
 as if they are the nextNode, not that they are two bridges.
 Need to test this...
********************************************
10/9/2011
All defines set
Delays changed to moveTicks()
Now double checks when it thinks it found a bridge, just in case it is actually a cross
Added error correction so it should stay on line
for error correction SIGNS MAY BE BACKWARDS!
Reorganised code so it should run on the arduino, yet to do a compile
Mapping finished(except for some kind of signal that the robot has finished), needs to be tested
*******************************************
6/9/2011
Got some movement in the mapping phase
imported turnTo() from the openDay code
Don't know what the error or motor speed should be for motorForward()
removed the commented out 8 bit array define thing, not needed here
add reading sensors
made a nice set of defines for the sensors so it's easy to read
did if statements that concern sensor readings
removed old 28x28 code, this one seems much nicer now
Made a description of how the grid represents the maze and how the path planner will use the grid
Commented a few of the functions
added a break from the for loop
*******************************************
5/9/2011
Need grid.getTerrain(Direction inDirection)
Binary array abstracted, may be implemented in Grid
Tidied up the code a lot, fixed some logic errors, decided on a type for "connections"
I want to start freeing up memory after finishing with some things, not entirely sure how C++ does it
Stole some of Todd's code for getting a path and following it, put in moveTo()
need to be able to query robot for the sensor configuration and **SCAN WHILE MOVING**
step size and sign corrected
got timer set up
******************************************
4/9/2011
CODE DOES NOT REFLECT BINARY ARRAY YET (might do that in Grid though, we'll see)
NORTH == UP, depends on the grid, NOT the robot's initial direction (as it is in the Robot class).  Important.
8 bit binary array will be implemented in place of Terrain enum:
[ABCDEFGH]
A: NORTH
B: EAST
C: SOUTH
D: WEST
E: UNKNOWN
F: PASSABLE
G: NOT NORTH OR SOUTH (When G is set, A and C mean !NORTH and !SOUTH respectively)
H: NOT EAST OR WEST (When H is set, B and D mean !EAST and !WEST respectively)
//using G and H we only need to check 3 sides of each square because we can use logic to work out the last side.
examples:
[10010000] = From node can go north and west
[10010010] = From node can go west and NOT north 
	==
[00110000] = From node can go south and west
*****************************************/

/*******************************************
Representation of the maze in this code:
The maze:
 _ _ _ _ 
|/  |   |
|_ _|_ _|
|   |   |
|_ _|_ /x

The grid:
  0 1 2 3 4
0 A V A V A
1 V C V C V
2 A V A V A
3 V C V C V
4 A V A V A

2x2 squares = 5x5 points in our grid
C = centre node (Nodes that represent the centre of the squares)
V = virtual nodes (Nodes on the sides of the squares, not really "nodes" and hence "virtual")
A = "crosses" (Nodes that represent the corners of the squares)

To initialise we set the grid like this:
  0 1 2 3 4
0 U G U G U <- start here
1 F N F N F
2 U G U G U
3 G N F N F
4 U G U G U

N = not passable (we should never try to cross a centre node, they are unpassable)
G = able to traverse EAST/WEST
F = able to traverse NORTH/SOUTH
U = unknown (all the crosses are either passable or unpassable, we need to check them)
Initialised in the Grid object because it is much easier to do it there

Imagine a robot starting at (4,0), moving west
as it moves it scans
it sees nothing at (3,0) so it keeps going
it sees a cross at (2,0) so it knows that the node is passable and that there is no bridge at (3,0)

  0 1 2 3 4
0 U G P P P
1 F N F N F
2 U G U G U
3 G N F N F
4 U G U G U
 
 P = PASSABLE, getting set to PASSABLE eliminates all diagonal directions but preserves cardinal directions. Also kills all diagonal directions that connect to that node

 at (0,1) is sees a bridge so it sets the centre
 at (0,0) it sees a cross and marks the node passable
 
 
  0 1 2 3 4
0 P Y P P P
1 A N C N F
2 U B U G U
3 G N F N F
4 U G U G U


\|/
 A
/|

-B-
/ \

\|  (NE connection was killed when (0,3) was set to PASSABLE)
 C
 |\

Y = preserves cardinal directions and SOUTHWARDS connections
A,B,C = preserves cardinal directions but kills all diagonal directions within the square that can't connect to Y

at (1,0) it will see the other side of the bridge:
  0 1 2 3 4
0 P Y P P P
1 A N C N F
2 U B U G U
3 G N F N F
4 U G U G U

\|/
 A
/|

-B-
/ \

 |  (NE connection was killed when (0,3) was set to PASSABLE)
 C
 |\
 

Final grid:
   0 1 2 3 4
0 P A P P P
1 A N P N P
2 P P P P P
3 P N P N A
4 P P P A N

Where adjacent A's preserve diagonal connections to each other
All other diagonal connections are lost

**************** path finding ***************
Using the previous grid:
We want to get from (0,1) to (1,0) using the bridge
To determine the existence of a path the path planner checks if there is a connection between the two nodes before adding them to the open list

A path is generated and passed to us:
LOOP
	We pull out a point from the path
	Turn towards that point
	move forward 1 point
END LOOP
********************************************/